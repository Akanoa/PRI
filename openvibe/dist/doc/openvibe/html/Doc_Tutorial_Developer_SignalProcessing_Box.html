<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>OpenViBE documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- <link href="tabs.css" rel="stylesheet" type="text/css"> -->
</head>
<body>
<div id="main">
	<div id="title">
		<center>
		<a name="page-top"></a>
		<table width=95%>
			<tr>
				<td><a href="http://openvibe.inria.fr" class="leaving-link" onclick="window.open(this.href,'openvibe-software'); return false;"><img src="logo.png" /></a></td>
				<td width=100%>OpenViBE Documentation</td>
			</tr>
		</table>
		</center>
	</div>
	<div id="menu">
		<div id="menu-content">
			<ul>
				<li><a href="index.html">OpenViBE Documentation</a></li>
			</ul>
			<div class="menu-title">Doxygen</div>
			<ul>
				<!-- <li><a href="pages.html">Related</a></li> -->
				<li><a href="modules.html">Modules</a></li>
				<li><a href="namespaces.html">Namespaces</a></li>
				<li><a href="annotated.html">Class List</a>
				<li><a href="classes.html">Class Index</a>
				<li><a href="hierarchy.html">Class Hierarchy</a>
				<!-- <li><a href="files.html">Files (buggy)</a></li> -->
			</ul>
			<div class="menu-title">Quick Access</div>
			<ul>
				<li><a href="http://openvibe.inria.fr/start" class="leaving-link">Video Tutorials</a></li>
				<li><a href="http://openvibe.inria.fr/faq">FAQ</a></li>
				<li><a href="http://openvibe.inria.fr/license">Licence</a></li>
				<li><a href="http://openvibe.inria.fr/build-instructions/">Build Instructions</a></li>
				<li><a href="http://openvibe.inria.fr/documentation-index/#User+Documentation">User Doc</a></li>
				<li><a href="http://openvibe.inria.fr/documentation-index/#Developer+Documentation">Developer Doc</a></li>
				<li><a href="Doc_BoxAlgorithms.html">Exisiting Boxes</a></li>
			</ul>
			<div class="menu-title">Contact</div>
			<ul>
				<li><a href="http://openvibe.inria.fr" class="leaving-link" onclick="window.open(this.href,'openvibe-software'); return false;">Software Home</a></li>
				<li><a href="http://openvibe.inria.fr/forum" class="leaving-link" onclick="window.open(this.href,'openvibe-forum'); return false;">Forum</a></li>
				<li><a href="https://gforge.inria.fr/projects/openvibe" class="leaving-link" onclick="window.open(this.href,'openvibe-forge'); return false;">INRIA gForge</a></li>
				<li><a href="https://gforge.inria.fr/mail/?group_id=276" class="leaving-link" onclick="window.open(this.href,'openvibe-forge'); return false;">Mailing Lists</a></li>
				<li><a href="http://openvibe.inria.fr/tracker" class="leaving-link" onclick="window.open(this.href,'openvibe-tracker'); return false;">Bug Tracker</a></li>
				<li><a href="http://www.irisa.fr/bunraku/OpenViBE/wiki/index.php?title=Main_Page" class="leaving-link" onclick="window.open(this.href,'openvibe-wiki'); return false;">Research Project</a></li>
				<li><b>IRC</b> : <span style="font-size: x-small; font-style: italic;">#openvibe</span> on <span style="font-size: x-small; font-style: italic;">irc.freenode.net</span></li>
				<li><b>Project Leader</b> : Anatole L&eacute;cuyer, Inria <span style="font-size: x-small; font-style: italic;">(anatole dot lecuyer at inria dot fr)</span></li>
				<li><b>Lead Software Engineer</b> : Laurent Bonnet, Inria <span style="font-size: x-small; font-style: italic;">(laurent dot bonnet at inria dot fr)</span></li>
			</ul>
			<div class="menu-title">Share this</div>
			<ul><li><span style="font-size: x-small; font-style: italic;">This documentation is licenced under <b>CC-BY-SA</b></span></li></ul>
			<td><a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode" class="leaving-link" onclick="window.open(this.href,'cc-by-sa'); return false;"><img src="cc-by-sa.png" /></a></td>
			<br>
			<div class="menu-title">Search</div>
			<form action="search.php" method="get" id="search">
				<fieldset>
					<input class="search" type="text" name="q" value="Quick Search..." onfocus="this.value='';" />
				</fieldset>
			</form>
		</div>
	</div>
	<div class="content-container">
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="Doc_DeveloperDocumentation.html">Developer Documentation</a></li><li class="navelem"><a class="el" href="Doc_DeveloperTutorials.html">Developer tutorials</a></li><li class="navelem"><a class="el" href="Doc_DeveloperDocumentation_Plugin.html">Developing a Plugin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Implementing a Box </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="important"> This documentation page is deprecated since <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> 0.12.0 (oct 2011), and won't be maintained.  The new page can be found  <a href="http://openvibe.inria.fr/tutorial-1-implementing-a-signal-processing-box/"> here </a> .</div><ul>
<li><b>NB:</b> Document based on <b> <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> 0.8.0 </b> (30-sep-2010).</li>
</ul>
<p>This section of the tutorial presents a detailed implementation of the <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> box that uses the signal processing algorithm. It is made of two distinct parts : the <a class="el" href="Doc_Tutorial_Developer_SignalProcessing_Box.html#Doc_Tutorial_Developer_SignalProcessing_BoxAlgorithmHeader">Box algorithm definition</a> (c++ header file) and the <a class="el" href="Doc_Tutorial_Developer_SignalProcessing_Box.html#Doc_Tutorial_Developer_SignalProcessing_BoxAlgorithmImplementation">Box algorithm implementation</a> (c++ cpp file).</p>
<h1><a class="anchor" id="Doc_Tutorial_Developer_SignalProcessing_BoxAlgorithmHeader"></a>
Box algorithm definition</h1>
<p>Here is the file containing the box algorithm definition, we will detail each line of the file later on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef __OpenViBEPlugins_BoxAlgorithm_SignalProcessingBoxAlgorithm_H__</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define __OpenViBEPlugins_BoxAlgorithm_SignalProcessingBoxAlgorithm_H__</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#include &quot;../../ovp_defines.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;openvibe/ov_all.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;openvibe-toolkit/ovtk_all.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define OVP_ClassId_BoxAlgorithm_SignalProcessingBoxAlgorithm OpenViBE::CIdentifier(0x330E3A87, 0x31565BA6)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define OVP_ClassId_BoxAlgorithm_SignalProcessingBoxAlgorithmDesc OpenViBE::CIdentifier(0x376A4712, 0x1AA65567)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="keyword">namespace </span>OpenViBEPlugins</div>
<div class="line">{</div>
<div class="line">        <span class="keyword">namespace </span>Samples</div>
<div class="line">        {</div>
<div class="line">                <span class="keyword">class </span>CBoxAlgorithmSignalProcessingBoxAlgorithm : <span class="keyword">virtual</span> <span class="keyword">public</span> OpenViBEToolkit::TBoxAlgorithm &lt; OpenViBE::Plugins::IBoxAlgorithm &gt;</div>
<div class="line">                {</div>
<div class="line">                <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">                        <span class="keyword">virtual</span> <span class="keywordtype">void</span> release(<span class="keywordtype">void</span>) { <span class="keyword">delete</span> <span class="keyword">this</span>; }</div>
<div class="line"></div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> initialize(<span class="keywordtype">void</span>);</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> uninitialize(<span class="keywordtype">void</span>);</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> processInput(<a class="code" href="namespaceOpenViBE.html#a1134b580f8da4de94ca6b1de4d37975e" title="32 bits unsigned integer">OpenViBE::uint32</a> ui32InputIndex);</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> process(<span class="keywordtype">void</span>);</div>
<div class="line"></div>
<div class="line">                        _IsDerivedFromClass_Final_(OpenViBEToolkit::TBoxAlgorithm &lt; OpenViBE::Plugins::IBoxAlgorithm &gt;, OVP_ClassId_BoxAlgorithm_SignalProcessingBoxAlgorithm);</div>
<div class="line"></div>
<div class="line">                <span class="keyword">protected</span>:</div>
<div class="line"></div>
<div class="line">                        <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> m_bActive;</div>
<div class="line"></div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html" title="Application interface to an algorithm plugin.">OpenViBE::Kernel::IAlgorithmProxy</a>* m_pSignalDecoder;</div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; const OpenViBE::IMemoryBuffer* &gt;</a> ip_pMemoryBufferToDecode;</div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::uint64 &gt;</a> op_ui64SamplingRate;</div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::IMatrix* &gt;</a> op_pDecodedMatrix;</div>
<div class="line"></div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html" title="Application interface to an algorithm plugin.">OpenViBE::Kernel::IAlgorithmProxy</a>* m_pSignalProcessingAlgorithm;</div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::IMatrix* &gt;</a> ip_pSignalProcessingAlgorithmMatrix;</div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::IMatrix* &gt;</a> op_pSignalProcessingAlgorithmMatrix;</div>
<div class="line"></div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html" title="Application interface to an algorithm plugin.">OpenViBE::Kernel::IAlgorithmProxy</a>* m_pSignalEncoder;</div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::uint64 &gt;</a> ip_ui64SamplingRate;</div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::IMatrix* &gt;</a> ip_pMatrixToEncode;</div>
<div class="line">                        <a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::IMemoryBuffer* &gt;</a> op_pEncodedMemoryBuffer;</div>
<div class="line">                };</div>
<div class="line"></div>
<div class="line">                <span class="keyword">class </span>CBoxAlgorithmSignalProcessingBoxAlgorithmDesc : <span class="keyword">virtual</span> <span class="keyword">public</span> <a class="code" href="classOpenViBE_1_1Plugins_1_1IBoxAlgorithmDesc.html" title="Box algorithm plugin descriptorThis class should be derived by any plugin developper in order to desc...">OpenViBE::Plugins::IBoxAlgorithmDesc</a></div>
<div class="line">                {</div>
<div class="line">                <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">                        <span class="keyword">virtual</span> <span class="keywordtype">void</span> release(<span class="keywordtype">void</span>) { }</div>
<div class="line"></div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a> getName(<span class="keywordtype">void</span>)<span class="keyword"> const                </span>{ <span class="keywordflow">return</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a>(<span class="stringliteral">&quot;Signal processing box algorithm&quot;</span>); }</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a> getAuthorName(<span class="keywordtype">void</span>)<span class="keyword"> const          </span>{ <span class="keywordflow">return</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a>(<span class="stringliteral">&quot;Yann Renard&quot;</span>); }</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a> getAuthorCompanyName(<span class="keywordtype">void</span>)<span class="keyword"> const   </span>{ <span class="keywordflow">return</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a>(<span class="stringliteral">&quot;INRIA&quot;</span>); }</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a> getShortDescription(<span class="keywordtype">void</span>)<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a>(<span class="stringliteral">&quot;This is a sample signal processing box algorithm that uses the sample signal processing algorithm in order to demonstrate how to build a signal processing box algorithm&quot;</span>); }</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a> getDetailedDescription(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a>(<span class="stringliteral">&quot;&quot;</span>); }</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a> getCategory(<span class="keywordtype">void</span>)<span class="keyword"> const            </span>{ <span class="keywordflow">return</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a>(<span class="stringliteral">&quot;Samples&quot;</span>); }</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a> getVersion(<span class="keywordtype">void</span>)<span class="keyword"> const             </span>{ <span class="keywordflow">return</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a>(<span class="stringliteral">&quot;1.0&quot;</span>); }</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a> getStockItemName(<span class="keywordtype">void</span>)<span class="keyword"> const       </span>{ <span class="keywordflow">return</span> <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">OpenViBE::CString</a>(<span class="stringliteral">&quot;gtk-execute&quot;</span>); }</div>
<div class="line"></div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1CIdentifier.html" title="Globally used identifiaction classThis class is the basic class to use in order to identify objects i...">OpenViBE::CIdentifier</a> getCreatedClass(<span class="keywordtype">void</span>)<span class="keyword"> const    </span>{ <span class="keywordflow">return</span> OVP_ClassId_BoxAlgorithm_SignalProcessingBoxAlgorithm; }</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="classOpenViBE_1_1Plugins_1_1IPluginObject.html" title="Base class for plugin objectThis class is the base class for all the concrete plugin classes that ext...">OpenViBE::Plugins::IPluginObject</a>* create(<span class="keywordtype">void</span>)       { <span class="keywordflow">return</span> <span class="keyword">new</span> OpenViBEPlugins::Samples::CBoxAlgorithmSignalProcessingBoxAlgorithm; }</div>
<div class="line"></div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> getBoxPrototype(</div>
<div class="line">                                <a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxProto.html" title="OpenViBE box prototypeThis class is used by a plugin algorithm descriptor to let the OpenViBE platfor...">OpenViBE::Kernel::IBoxProto</a>&amp; rBoxAlgorithmPrototype)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">                        </span>{</div>
<div class="line">                                rBoxAlgorithmPrototype.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxProto.html#acc681d41da652463aa011dfaac32bcfb" title="Adds an input to the box.">addInput</a>  (<span class="stringliteral">&quot;Input signal&quot;</span>,  OV_TypeId_Signal);</div>
<div class="line">                                rBoxAlgorithmPrototype.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxProto.html#a3b0ae138e8cc8d78adde3af9fc7e07cd" title="Adds an output to the box.">addOutput</a> (<span class="stringliteral">&quot;Output signal&quot;</span>, OV_TypeId_Signal);</div>
<div class="line">                                rBoxAlgorithmPrototype.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxProto.html#ace25ad0abe7a54cafc5c99a49ac8732a" title="Adds an setting to the box.">addSetting</a>(<span class="stringliteral">&quot;Active&quot;</span>, OV_TypeId_Boolean, <span class="stringliteral">&quot;true&quot;</span>);</div>
<div class="line">                                rBoxAlgorithmPrototype.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxProto.html#a57247fd552b70a612e2054b874c52c4f" title="Adds a flag to the box.">addFlag</a>   (OpenViBE::Kernel::BoxFlag_IsUnstable);</div>
<div class="line">                                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                        }</div>
<div class="line"></div>
<div class="line">                        _IsDerivedFromClass_Final_(<a class="code" href="classOpenViBE_1_1Plugins_1_1IBoxAlgorithmDesc.html" title="Box algorithm plugin descriptorThis class should be derived by any plugin developper in order to desc...">OpenViBE::Plugins::IBoxAlgorithmDesc</a>, OVP_ClassId_BoxAlgorithm_SignalProcessingBoxAlgorithmDesc);</div>
<div class="line">                };</div>
<div class="line">        };</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif // __OpenViBEPlugins_BoxAlgorithm_SignalProcessingBoxAlgorithm_H__</span></div>
</div><!-- fragment --> <p>First of all, we will include every identifier / define needed for this plugin to work. The <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> toolkit will help in the implementation so we include it also. <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../../ovp_defines.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;openvibe/ov_all.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;openvibe-toolkit/ovtk_all.h&gt;</span></div>
</div><!-- fragment --></p>
<p>The next part defines all the unique CIdentifier objects that identify the box and its descriptor. These random identifiers can be generated randomly using the dedicated tool <b>id-generator</b>, provided by the <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> software platform. Please be sure to use <b>unique</b> identifiers. <div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">#define OVP_ClassId_BoxAlgorithm_SignalProcessingBoxAlgorithm OpenViBE::CIdentifier(0x330E3A87, 0x31565BA6)</span></div>
<div class="line"><span class="preprocessor">#define OVP_ClassId_BoxAlgorithm_SignalProcessingBoxAlgorithmDesc OpenViBE::CIdentifier(0x376A4712, 0x1AA65567)</span></div>
</div><!-- fragment --></p>
<p>In order to avoid name collisions, it is desirable to define all classes within namespaces. All standard <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> plugins are defined in sub namespaces of OpenViBEPlugins. <div class="fragment"><div class="line"></div>
<div class="line"><span class="keyword">namespace </span>OpenViBEPlugins</div>
<div class="line">{</div>
<div class="line">        <span class="keyword">namespace </span>Samples</div>
<div class="line">        {</div>
</div><!-- fragment --></p>
<p>We are now working within the OpenViBEPlugins::Samples namespace. We have to define two classes : the box descriptor and the box algorithm itself. The descriptor is retrieved by the kernel at startup to get general information about the box algorithm. It is this descriptor which allows to create actual instances of this box algorithm.</p>
<p>The interface common to all box algorithms is IBoxAlgorithm. However, box algorithm implementation is made easier thanks to the OpenViBEToolkit::TBoxAlgorithm template, which implements operations common to all box algorithms such as direct access to managers. We therfore inherit from this template, using the IBoxAlgorithm interface as template argument. <div class="fragment"><div class="line">                <span class="keyword">class </span>CBoxAlgorithmSignalProcessingBoxAlgorithm : <span class="keyword">virtual</span> <span class="keyword">public</span> OpenViBEToolkit::TBoxAlgorithm &lt; OpenViBE::Plugins::IBoxAlgorithm &gt;</div>
<div class="line">                {</div>
</div><!-- fragment --></p>
<p>We start by declaring the release method which deletes the box algorithm. <div class="fragment"><div class="line">                <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">                        <span class="keyword">virtual</span> <span class="keywordtype">void</span> release(<span class="keywordtype">void</span>) { <span class="keyword">delete</span> <span class="keyword">this</span>; }</div>
</div><!-- fragment --></p>
<p>The core of a box algorithm is split into three methods : initialize, uninitialize and process. Additionally, a box algorithm can use several notification callbacks for input reception, clock ticks, message reception...</p>
<p>Its life cycle looks like the following :</p>
<ul>
<li>one initialize call,</li>
<li>several notification/process calls</li>
<li>one uninitialize call.</li>
</ul>
<p>Each of these methods returns a boolean reflecting whether it operated successfully. If any of these methods returns false, the kernel will stop using the box-algorithm. <div class="fragment"><div class="line"></div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> initialize(<span class="keywordtype">void</span>);</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> uninitialize(<span class="keywordtype">void</span>);</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> processInput(<a class="code" href="namespaceOpenViBE.html#a1134b580f8da4de94ca6b1de4d37975e" title="32 bits unsigned integer">OpenViBE::uint32</a> ui32InputIndex);</div>
<div class="line">                        <span class="keyword">virtual</span> <a class="code" href="namespaceOpenViBE.html#af29b166bf5fea7f0bbc07f7014a8c6b5" title="Boolean.">OpenViBE::boolean</a> process(<span class="keywordtype">void</span>);</div>
</div><!-- fragment --></p>
<p>As with any other <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> class, the box algorithm should be given a class identifier. This is easily done using the <code><em>IsDerivedFromClass_Final</em></code> macro. <div class="fragment"></div><!-- fragment --></p>
<p>The m_bActive member will be used to activate/deactivate the box from the Designer. <div class="fragment"></div><!-- fragment --></p>
<p>The box implementation heavily relies on algorithms to do its job. This signal processing box algorithm will use three algorithms :</p>
<ul>
<li>the first is responsible for decoding the input stream,</li>
<li>the second does the actual signal processing, and</li>
<li>the last one encodes the output stream.</li>
</ul>
<p>Each of these algorithms has input and/or output parameters. In order to facilite access to these parameters, our box algorithm embeds them in parameter handlers.</p>
<p>First, we define the signal decoder and its associated parameter handlers. The signal decoder takes a memory buffer to decode and produces a signal matrix and an unsigned integer holding the sampling rate. <div class="fragment"></div><!-- fragment --></p>
<p>Second, we define the signal processing algorithm and its associated parameter handlers. This is the algorithm that was designed earlier in this tutorial. It takes a signal matrix as input and produces a new signal matrix as output. <div class="fragment"></div><!-- fragment --></p>
<p>Lastly, we define the signal encoder and its associated parameter handlers. The signal encoder takes a signal matrix and an unsigned integer for the sampling rate as inputs and produces a memory buffer as output. <div class="fragment"></div><!-- fragment --></p>
<p>We're done with the declaration of the box algorithm, and move on to the descriptor. It provides information about the box algorithm, including its name, author, version and so on. The 'category' it should appear get listed under in the Designer may be specified here as well. <div class="fragment"></div><!-- fragment --></p>
<p>The descriptor also allows to create actual instances of the box algorithm. To that end, it tells the kernel what kind of box it can create and then the create method performs the instanciation. <div class="fragment"></div><!-- fragment --></p>
<p>The getBoxPrototype method retrieves the prototype of the box, i.e. a description of its inputs and outputs as well as its settings and flags.</p>
<ul>
<li>Inputs and outputs are streams and will have to be decoded / encoded by specific algorithms.</li>
<li>Settings offer a way to preconfigure a box before using it.</li>
<li>Flags are used to remind the user about some unusual properties of a box, such as its being under development ('unstable' flag) or deprecated.</li>
</ul>
<p><div class="fragment"></div><!-- fragment --></p>
<p>Our signal processing box will have one input and one output, both of 'signal' type. <div class="fragment"></div><!-- fragment --></p>
<p>Here a single boolean setting is declared and meant to hold the initial activation state. <div class="fragment"></div><!-- fragment --></p>
<p>Since this box is only meant to be used as a testbed, it is safer to flag it as unstable so as not to be mistaken with more robust boxes! <div class="fragment"></div><!-- fragment --></p>
<p>Finally, the descriptor returns true, notifying the kernel the box prototype was successfully retrieved. <div class="fragment"></div><!-- fragment --></p>
<p>Of course, the descriptor also has to be given an identifier using the <code><em>IsDerivedFromClass_Final</em></code> macro. <div class="fragment"></div><!-- fragment --></p>
<h1><a class="anchor" id="Doc_Tutorial_Developer_SignalProcessing_BoxAlgorithmImplementation"></a>
Box algorithm implementation</h1>
<p>Here is the file containing the box algorithm implementation, we will detail each line of the file later on.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ovpCBoxAlgorithmSignalProcessingBoxAlgorithm.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>OpenViBE;</div>
<div class="line"><span class="keyword">using namespace </span>OpenViBE::Kernel;</div>
<div class="line"><span class="keyword">using namespace </span>OpenViBE::Plugins;</div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>OpenViBEPlugins;</div>
<div class="line"><span class="keyword">using namespace </span>OpenViBEPlugins::Samples;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">boolean</span> CBoxAlgorithmSignalProcessingBoxAlgorithm::initialize(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="classOpenViBE_1_1Kernel_1_1IBox.html" title="Complete OpenViBE box interfaceThis interface can be used in order to fully describe an OpenViBE blac...">IBox</a>&amp; l_rStaticBoxContext=this-&gt;getStaticBoxContext();</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classOpenViBE_1_1CString.html" title="String class to avoid std::string in the interfaceThis class helps avoiding std::string being present...">CString</a> l_sActive;</div>
<div class="line">        l_rStaticBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBox.html#a22745b85c269c80acc94b48be67c963c" title="Gets the setting value.">getSettingValue</a>(0, l_sActive);</div>
<div class="line">        m_bActive=this-&gt;getConfigurationManager().expandAsBoolean(l_sActive);</div>
<div class="line"></div>
<div class="line">        m_pSignalDecoder=&amp;this-&gt;getAlgorithmManager().getAlgorithm(this-&gt;getAlgorithmManager().createAlgorithm(OVP_GD_ClassId_Algorithm_SignalStreamDecoder));</div>
<div class="line">        m_pSignalDecoder-&gt;initialize();</div>
<div class="line">        ip_pMemoryBufferToDecode.initialize(m_pSignalDecoder-&gt;getInputParameter(OVP_GD_Algorithm_SignalStreamDecoder_InputParameterId_MemoryBufferToDecode));</div>
<div class="line">        op_ui64SamplingRate.initialize(m_pSignalDecoder-&gt;getOutputParameter(OVP_GD_Algorithm_SignalStreamDecoder_OutputParameterId_SamplingRate));</div>
<div class="line">        op_pDecodedMatrix.initialize(m_pSignalDecoder-&gt;getOutputParameter(OVP_GD_Algorithm_SignalStreamDecoder_OutputParameterId_Matrix));</div>
<div class="line"></div>
<div class="line">        m_pSignalProcessingAlgorithm=&amp;this-&gt;getAlgorithmManager().getAlgorithm(this-&gt;getAlgorithmManager().createAlgorithm(OVP_ClassId_Algorithm_SignalProcessingAlgorithm));</div>
<div class="line">        m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#ad58fbcdf752604b2392266a0c77f93cd" title="Initializes the algorithm.">initialize</a>();</div>
<div class="line">        ip_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a7511aca374e126f43beb7879d57699c7" title="Connects this parameter handler to a concrete IParameter pointer.">initialize</a>(m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a01ed90db74b699befce9cad8704e2ffd" title="Gets the parameter details of a specific input parameter.">getInputParameter</a>(OVP_Algorithm_SignalProcessingAlgorithm_InputParameterId_Matrix));</div>
<div class="line">        op_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a7511aca374e126f43beb7879d57699c7" title="Connects this parameter handler to a concrete IParameter pointer.">initialize</a>(m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a68d15f4727a654c413b013f092247000" title="Gets the parameter details of a specific output parameter.">getOutputParameter</a>(OVP_Algorithm_SignalProcessingAlgorithm_OutputParameterId_Matrix));</div>
<div class="line"></div>
<div class="line">        m_pSignalEncoder=&amp;this-&gt;getAlgorithmManager().getAlgorithm(this-&gt;getAlgorithmManager().createAlgorithm(OVP_GD_ClassId_Algorithm_SignalStreamEncoder));</div>
<div class="line">        m_pSignalEncoder-&gt;initialize();</div>
<div class="line">        ip_ui64SamplingRate.initialize(m_pSignalEncoder-&gt;getInputParameter(OVP_GD_Algorithm_SignalStreamEncoder_InputParameterId_SamplingRate));</div>
<div class="line">        ip_pMatrixToEncode.initialize(m_pSignalEncoder-&gt;getInputParameter(OVP_GD_Algorithm_SignalStreamEncoder_InputParameterId_Matrix));</div>
<div class="line">        op_pEncodedMemoryBuffer.initialize(m_pSignalEncoder-&gt;getOutputParameter(OVP_GD_Algorithm_SignalStreamEncoder_OutputParameterId_EncodedMemoryBuffer));</div>
<div class="line"></div>
<div class="line">        ip_ui64SamplingRate.setReferenceTarget(op_ui64SamplingRate);</div>
<div class="line">        ip_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a07b427c2abdd0c5e20924ede4d613f57" title="Sets a new reference target.">setReferenceTarget</a>(op_pDecodedMatrix);</div>
<div class="line">        ip_pMatrixToEncode.setReferenceTarget(op_pSignalProcessingAlgorithmMatrix);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">boolean</span> CBoxAlgorithmSignalProcessingBoxAlgorithm::uninitialize(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">        ip_pMatrixToEncode.uninitialize();</div>
<div class="line">        ip_ui64SamplingRate.uninitialize();</div>
<div class="line">        m_pSignalEncoder-&gt;uninitialize();</div>
<div class="line">        this-&gt;getAlgorithmManager().releaseAlgorithm(*m_pSignalEncoder);</div>
<div class="line"></div>
<div class="line">        op_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a3c4612264cb495eb776e7a70aabea9b7" title="Disconnects this parameter handler from its concrete IParameter pointer.">uninitialize</a>();</div>
<div class="line">        ip_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a3c4612264cb495eb776e7a70aabea9b7" title="Disconnects this parameter handler from its concrete IParameter pointer.">uninitialize</a>();</div>
<div class="line">        m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#addb3e86e8e097bbe3964e82aa104225f" title="Uninitializes the algorithm.">uninitialize</a>();</div>
<div class="line">        this-&gt;getAlgorithmManager().releaseAlgorithm(*m_pSignalProcessingAlgorithm);</div>
<div class="line"></div>
<div class="line">        op_pDecodedMatrix.uninitialize();</div>
<div class="line">        op_ui64SamplingRate.uninitialize();</div>
<div class="line">        m_pSignalDecoder-&gt;uninitialize();</div>
<div class="line">        this-&gt;getAlgorithmManager().releaseAlgorithm(*m_pSignalDecoder);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">boolean</span> CBoxAlgorithmSignalProcessingBoxAlgorithm::processInput(<a class="code" href="namespaceOpenViBE.html#a1134b580f8da4de94ca6b1de4d37975e" title="32 bits unsigned integer">uint32</a> ui32InputIndex)</div>
<div class="line">{</div>
<div class="line">        this-&gt;getBoxAlgorithmContext()-&gt;markAlgorithmAsReadyToProcess();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">boolean</span> CBoxAlgorithmSignalProcessingBoxAlgorithm::process(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html" title="Main OpenViBE box interface to communicate with the kernelThis context allows the object which uses i...">IBoxIO</a>&amp; l_rDynamicBoxContext=this-&gt;getDynamicBoxContext();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(<a class="code" href="namespaceOpenViBE.html#a1134b580f8da4de94ca6b1de4d37975e" title="32 bits unsigned integer">uint32</a> i=0; i&lt;l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#ac92f046ed273ed5329ef1d6240b70d12" title="Gets the number of pending chunks for an input.">getInputChunkCount</a>(0); i++)</div>
<div class="line">        {</div>
<div class="line">                ip_pMemoryBufferToDecode=l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#a45b2989bae9783fedfc91846422df375" title="Gets an input chunk and its time validity.">getInputChunk</a>(0, i);</div>
<div class="line">                op_pEncodedMemoryBuffer=l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#a49a928579ab97e014dbc7f9e59c6e0cb" title="Gets an output chunk.">getOutputChunk</a>(0);</div>
<div class="line"></div>
<div class="line">                m_pSignalDecoder-&gt;process();</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span>(m_pSignalDecoder-&gt;isOutputTriggerActive(OVP_GD_Algorithm_SignalStreamDecoder_OutputTriggerId_ReceivedHeader))</div>
<div class="line">                {</div>
<div class="line">                        m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a02c9114b1cbeaf0ec9904f27d63035ca" title="Calls the processing method of the algorithm.">process</a>(OVP_Algorithm_SignalProcessingAlgorithm_InputTriggerId_Initialize);</div>
<div class="line">                        m_pSignalEncoder-&gt;process(OVP_GD_Algorithm_SignalStreamEncoder_InputTriggerId_EncodeHeader);</div>
<div class="line"></div>
<div class="line">                        l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#a86a12d874a8db34e5a751dc0e076e340" title="Marks output buffer as &#39;ready to send&#39;.">markOutputAsReadyToSend</a>(0, l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#aa890f7569cc95bfea18d3fffc4336e81" title="Gets an input chunk start time.">getInputChunkStartTime</a>(0, i), l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#ad2e4cceed339fe531e2b22efcc54d6c3" title="Gets an input chunk end time.">getInputChunkEndTime</a>(0, i));</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span>(m_pSignalDecoder-&gt;isOutputTriggerActive(OVP_GD_Algorithm_SignalStreamDecoder_OutputTriggerId_ReceivedBuffer))</div>
<div class="line">                {</div>
<div class="line">                        m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a02c9114b1cbeaf0ec9904f27d63035ca" title="Calls the processing method of the algorithm.">process</a>(OVP_Algorithm_SignalProcessingAlgorithm_InputTriggerId_Process);</div>
<div class="line"></div>
<div class="line">                        <span class="keywordflow">if</span>(m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#aa86df50552efb84ea08b442f0185e8b6" title="Tests whether an output trigger is activated or not.">isOutputTriggerActive</a>(OVP_Algorithm_SignalProcessingAlgorithm_OutputTriggerId_ProcessDone))</div>
<div class="line">                        {</div>
<div class="line">                                m_pSignalEncoder-&gt;process(OVP_GD_Algorithm_SignalStreamEncoder_InputTriggerId_EncodeBuffer);</div>
<div class="line"></div>
<div class="line">                                l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#a86a12d874a8db34e5a751dc0e076e340" title="Marks output buffer as &#39;ready to send&#39;.">markOutputAsReadyToSend</a>(0, l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#aa890f7569cc95bfea18d3fffc4336e81" title="Gets an input chunk start time.">getInputChunkStartTime</a>(0, i), l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#ad2e4cceed339fe531e2b22efcc54d6c3" title="Gets an input chunk end time.">getInputChunkEndTime</a>(0, i));</div>
<div class="line">                        }</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span>(m_pSignalDecoder-&gt;isOutputTriggerActive(OVP_GD_Algorithm_SignalStreamDecoder_OutputTriggerId_ReceivedEnd))</div>
<div class="line">                {</div>
<div class="line">                        m_pSignalEncoder-&gt;process(OVP_GD_Algorithm_SignalStreamEncoder_InputTriggerId_EncodeEnd);</div>
<div class="line"></div>
<div class="line">                        l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#a86a12d874a8db34e5a751dc0e076e340" title="Marks output buffer as &#39;ready to send&#39;.">markOutputAsReadyToSend</a>(0, l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#aa890f7569cc95bfea18d3fffc4336e81" title="Gets an input chunk start time.">getInputChunkStartTime</a>(0, i), l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#ad2e4cceed339fe531e2b22efcc54d6c3" title="Gets an input chunk end time.">getInputChunkEndTime</a>(0, i));</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                l_rDynamicBoxContext.<a class="code" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html#a0f7f4037553162afef9ea9c99dc3d5d5" title="Marks an input chunk as deprecated.">markInputAsDeprecated</a>(0, i);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> <p>First off, for easier development, it is convenient to declare using some common <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> namespaces so that they don't have to be explicitly typed every time. Again, such statements should never appear in in header files, but are acceptable in implementation files given that <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> does not have conflicting classes among its namespaces. <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ovpCBoxAlgorithmSignalProcessingBoxAlgorithm.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>OpenViBE;</div>
<div class="line"><span class="keyword">using namespace </span>OpenViBE::Kernel;</div>
<div class="line"><span class="keyword">using namespace </span>OpenViBE::Plugins;</div>
</div><!-- fragment --></p>
<p>The same can be done for the OpenViBEPlugins project namespaces. <div class="fragment"><div class="line"></div>
<div class="line"><span class="keyword">using namespace </span>OpenViBEPlugins;</div>
<div class="line"><span class="keyword">using namespace </span>OpenViBEPlugins::Samples;</div>
</div><!-- fragment --></p>
<p>Now we have two simple functions to implement, namely initialize and uninitialize. In our case, they consist in retrieving setting values, creating or releasing the necessary algorithms and connecting or disconnecting our parameter handlers to the actual parameters. These handlers will be used later to ease parameter value manipulation. <div class="fragment"><div class="line"></div>
<div class="line"><span class="keywordtype">boolean</span> CBoxAlgorithmSignalProcessingBoxAlgorithm::initialize(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
</div><!-- fragment --></p>
<p>The static box context allows to programmatically retrieve information about the box prototype, including the number of inputs / outputs / settings and their type. <div class="fragment"><div class="line">        IBox&amp; l_rStaticBoxContext=this-&gt;getStaticBoxContext();</div>
</div><!-- fragment --></p>
<p>Here we will use this static box context to retrieve the value of the "Active" setting. Settings are accessed with their 0-based index thanks to the getSettingValue function. The returned string may be parsed by the configuration manager. For example, in this case, we know the setting string is a boolean. So the expandAsBoolean function will return the boolean value corresponding to the setting string. <div class="fragment"><div class="line"></div>
<div class="line">        CString l_sActive;</div>
<div class="line">        l_rStaticBoxContext.getSettingValue(0, l_sActive);</div>
<div class="line">        m_bActive=this-&gt;getConfigurationManager().expandAsBoolean(l_sActive);</div>
</div><!-- fragment --></p>
<p>Now we use the algorithm manager to create the three algorithms used by this box, then initialize these algorithms, and finally connect them together.</p>
<p>The stream decoder and encoder algorithms are common algorithms owned by another project in the platform. Their identifiers may be found in the ov_global_defines.h file which can be generated thanks to the plugin inspector tool.</p>
<p>Let's start with the signal decoder. It is created using the algorithm manager. Next, we initialize it.</p>
<p>Then we connect the parameter handlers of the box to their corresponding parameters. For example, ip_pMemoryBufferToDecode is the input memory buffer the decoder will work on. This parameter was declared in the decoder algorithm descriptor as being of type OV_TypeId_MemoryBuffer and with identifier OVP_GD_Algorithm_SignalStreamDecoder_InputParameterId_MemoryBufferToDecode. The parameter can be retrieved with the getInputParameter function and given to the handler. Past this point, ip_pMemoryBufferToDecode can be used as an IMemoryBuffer* pointer using the -&gt; operator.</p>
<p>The same is done to initialize the sampling rate output parameter of the box with the output parameter of the decoder. And the decoded matrix parameter handler is connected to the matrix output parameter of the decoder. <div class="fragment"><div class="line"></div>
<div class="line">        m_pSignalDecoder=&amp;this-&gt;getAlgorithmManager().getAlgorithm(this-&gt;getAlgorithmManager().createAlgorithm(OVP_GD_ClassId_Algorithm_SignalStreamDecoder));</div>
<div class="line">        m_pSignalDecoder-&gt;initialize();</div>
<div class="line">        ip_pMemoryBufferToDecode.initialize(m_pSignalDecoder-&gt;getInputParameter(OVP_GD_Algorithm_SignalStreamDecoder_InputParameterId_MemoryBufferToDecode));</div>
<div class="line">        op_ui64SamplingRate.initialize(m_pSignalDecoder-&gt;getOutputParameter(OVP_GD_Algorithm_SignalStreamDecoder_OutputParameterId_SamplingRate));</div>
<div class="line">        op_pDecodedMatrix.initialize(m_pSignalDecoder-&gt;getOutputParameter(OVP_GD_Algorithm_SignalStreamDecoder_OutputParameterId_Matrix));</div>
</div><!-- fragment --></p>
<p>Now we create and initialize the signal processing algorithm. This algorithm is defined in this project, so we can directly use the class identifier from the ovp_defines.h file. Then we connect our parameter handlers to their corresponding parameters. <div class="fragment"><div class="line"></div>
<div class="line">        m_pSignalProcessingAlgorithm=&amp;this-&gt;getAlgorithmManager().getAlgorithm(this-&gt;getAlgorithmManager().createAlgorithm(OVP_ClassId_Algorithm_SignalProcessingAlgorithm));</div>
<div class="line">        m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#ad58fbcdf752604b2392266a0c77f93cd" title="Initializes the algorithm.">initialize</a>();</div>
<div class="line">        ip_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a7511aca374e126f43beb7879d57699c7" title="Connects this parameter handler to a concrete IParameter pointer.">initialize</a>(m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a01ed90db74b699befce9cad8704e2ffd" title="Gets the parameter details of a specific input parameter.">getInputParameter</a>(OVP_Algorithm_SignalProcessingAlgorithm_InputParameterId_Matrix));</div>
<div class="line">        op_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a7511aca374e126f43beb7879d57699c7" title="Connects this parameter handler to a concrete IParameter pointer.">initialize</a>(m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a68d15f4727a654c413b013f092247000" title="Gets the parameter details of a specific output parameter.">getOutputParameter</a>(OVP_Algorithm_SignalProcessingAlgorithm_OutputParameterId_Matrix));</div>
</div><!-- fragment --></p>
<p>the last algorithm to create and initialize is the signal encoder. As for the decoder, we have to use the class identifier and the parameter identifiers from the ovp_global_defines.h file. <div class="fragment"><div class="line"></div>
<div class="line">        m_pSignalEncoder=&amp;this-&gt;getAlgorithmManager().getAlgorithm(this-&gt;getAlgorithmManager().createAlgorithm(OVP_GD_ClassId_Algorithm_SignalStreamEncoder));</div>
<div class="line">        m_pSignalEncoder-&gt;initialize();</div>
<div class="line">        ip_ui64SamplingRate.initialize(m_pSignalEncoder-&gt;getInputParameter(OVP_GD_Algorithm_SignalStreamEncoder_InputParameterId_SamplingRate));</div>
<div class="line">        ip_pMatrixToEncode.initialize(m_pSignalEncoder-&gt;getInputParameter(OVP_GD_Algorithm_SignalStreamEncoder_InputParameterId_Matrix));</div>
<div class="line">        op_pEncodedMemoryBuffer.initialize(m_pSignalEncoder-&gt;getOutputParameter(OVP_GD_Algorithm_SignalStreamEncoder_OutputParameterId_EncodedMemoryBuffer));</div>
</div><!-- fragment --></p>
<p>Now that algorithms and parameter handlers are initialized, we must forward decoded data to the signal processing algorithm, and then forward processed data to the encoding algorithm.</p>
<p>To facilite this, it is convenient to connect parameters together. This minimizes the efforts needed to pass data from one algorithm to the next.</p>
<p>For example, the signal processing algorithm does not change the sampling rate value. This means this parameter can be connected from the decoder straight to the encoder.</p>
<p>However, this is not the true of the decoded matrix, which must go through the signal processing algorithm first. This is where the setReferenceTarget method comes in handy. This method allows to link one parameter to another.</p>
<p>Past the following line, any modification on the value of the sampling rate parameter of the decoder will immediately affect the sampling rate parameter of the encoder. <div class="fragment"><div class="line"></div>
<div class="line">        ip_ui64SamplingRate.setReferenceTarget(op_ui64SamplingRate);</div>
</div><!-- fragment --></p>
<p>The following code block also makes use of setReferenceTarget to forward the signal matrix from one algorithm to another, and then to a third one.</p>
<p>The first statement links the decoder output matrix to the signal processing algorithm input matrix. The second statement links the processed matrix to the encoder input matrix. All parameters used here will actually share the same object value. <div class="fragment"><div class="line">        ip_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a07b427c2abdd0c5e20924ede4d613f57" title="Sets a new reference target.">setReferenceTarget</a>(op_pDecodedMatrix);</div>
<div class="line">        ip_pMatrixToEncode.setReferenceTarget(op_pSignalProcessingAlgorithmMatrix);</div>
</div><!-- fragment --></p>
<p>Again, returning true tells the kernel the box was correctly initialized. Returning false would have the kernel assume this box failed to initialize and it would stop calling it in the future. <div class="fragment"><div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>Uninitialization notifies the box algorithm that it won't be used anymore. Thus every initialized member should be freed and the whole environment should be left as it was before initialize was called. <div class="fragment"><div class="line"></div>
<div class="line"><span class="keywordtype">boolean</span> CBoxAlgorithmSignalProcessingBoxAlgorithm::uninitialize(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
</div><!-- fragment --></p>
<p>To release an algorithm, three steps have to be followed :</p>
<ul>
<li>disconnect parameter handlers from their embedded parameter by calling uninitialize.</li>
<li>call uninitialize on the algorithm itself</li>
<li>have the algorithm manager release the algorithm</li>
</ul>
<p>In the following code block, ip_pMatrixToEncode is disconnected from its parameter thanks to the uninitialize method. Past this point, using operator -&gt; will throw an exception and cause a crash. The same is done on each of the parameter handlers of the signal encoder. Then the signal encoder itself can be uninitialized and a request can be sent to the algorithm manager to release this algorithm that won't be used anymore. <div class="fragment"><div class="line">        ip_pMatrixToEncode.uninitialize();</div>
<div class="line">        ip_ui64SamplingRate.uninitialize();</div>
<div class="line">        m_pSignalEncoder-&gt;uninitialize();</div>
<div class="line">        this-&gt;getAlgorithmManager().releaseAlgorithm(*m_pSignalEncoder);</div>
</div><!-- fragment --></p>
<p>The signal processing algorithm is released next. <div class="fragment"><div class="line"></div>
<div class="line">        op_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a3c4612264cb495eb776e7a70aabea9b7" title="Disconnects this parameter handler from its concrete IParameter pointer.">uninitialize</a>();</div>
<div class="line">        ip_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a3c4612264cb495eb776e7a70aabea9b7" title="Disconnects this parameter handler from its concrete IParameter pointer.">uninitialize</a>();</div>
<div class="line">        m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#addb3e86e8e097bbe3964e82aa104225f" title="Uninitializes the algorithm.">uninitialize</a>();</div>
<div class="line">        this-&gt;getAlgorithmManager().releaseAlgorithm(*m_pSignalProcessingAlgorithm);</div>
</div><!-- fragment --></p>
<p>And finally, the signal decoder is released. <div class="fragment"><div class="line"></div>
<div class="line">        op_pDecodedMatrix.uninitialize();</div>
<div class="line">        op_ui64SamplingRate.uninitialize();</div>
<div class="line">        m_pSignalDecoder-&gt;uninitialize();</div>
<div class="line">        this-&gt;getAlgorithmManager().releaseAlgorithm(*m_pSignalDecoder);</div>
</div><!-- fragment --></p>
<p>Again, this function should return true to notify the kernel everything went on fine. <div class="fragment"><div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>All that is left to code now concerns event notification and data processing.</p>
<p>Let's start with notifications. A box can ask to be notified of different types of events, such as message arrival or clock ticks. This particular box only cares about input data arrival, an event upon which the box will trigger a data processing procedure. This is why a single event handler (processInput) is implemented here. <div class="fragment"><div class="line"></div>
<div class="line"><span class="keywordtype">boolean</span> CBoxAlgorithmSignalProcessingBoxAlgorithm::processInput(uint32 ui32InputIndex)</div>
<div class="line">{</div>
</div><!-- fragment --></p>
<p>Entering this method means there is pending input data. In this simple example, the box is ready to process such data as soon as it arrives. The following statement marks the box as candidate for such processing, which will lead to its process method to be called. on the input. <div class="fragment"><div class="line">        this-&gt;getBoxAlgorithmContext()-&gt;markAlgorithmAsReadyToProcess();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>On to the heart of the box implementation : the processing part. This is where input data chunks are retrieved in order to be decoded, processed and encoded before being forwarded to the next box as output chunks. <div class="fragment"><div class="line"></div>
<div class="line"><span class="keywordtype">boolean</span> CBoxAlgorithmSignalProcessingBoxAlgorithm::process(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
</div><!-- fragment --></p>
<p>The dynamic box context contains box communication information. Part of such information is made up of pending input chunks. Keeping a reference on this context allows to access directly input and output chunks. <div class="fragment"><div class="line">        IBoxIO&amp; l_rDynamicBoxContext=this-&gt;getDynamicBoxContext();</div>
</div><!-- fragment --></p>
<p>Notifying the kernel that a box algorithm is ready to process input data does not necessarily trigger an immediate process call. Therefore, multiple input chunks may be pending when process gets called eventually. This is why one should always iterate on input chunks to be sure none is left unprocessed.</p>
<p>Since our box has only one input, a single loop iterates over chunks of this input (index 0). <div class="fragment"><div class="line"></div>
<div class="line">        <span class="keywordflow">for</span>(uint32 i=0; i&lt;l_rDynamicBoxContext.getInputChunkCount(0); i++)</div>
<div class="line">        {</div>
</div><!-- fragment --></p>
<p>Each chunk retrieved from this input is going to be decoded, processed and encoded again.</p>
<p>Here, parameter handlers initialized earlier are told where to fetch input data and where to store output data. The getInputChunk method retreives input chunks from a given input (first argument) at a given index (second argument). Similarly, getOutputChunk retrieves output chunks from a given output at a given index. <div class="fragment"><div class="line">                ip_pMemoryBufferToDecode=l_rDynamicBoxContext.getInputChunk(0, i);</div>
<div class="line">                op_pEncodedMemoryBuffer=l_rDynamicBoxContext.getOutputChunk(0);</div>
</div><!-- fragment --></p>
<p>At this point, the box is ready to start processing the chunk. First, we have the decoder decode it. <div class="fragment"><div class="line"></div>
<div class="line">                m_pSignalDecoder-&gt;process();</div>
</div><!-- fragment --></p>
<p>The decoder has several output triggers telling us what was just decoded. There are three chunk categories :</p>
<ul>
<li>headers (received once per input)</li>
<li>buffers (received an undeterminate number of times, depending on how much data there is to process)</li>
<li>end nodes (received once per input).</li>
</ul>
<p>Depending on what was decoded, different actions will be undertaken. <div class="fragment"><div class="line"></div>
<div class="line">                <span class="keywordflow">if</span>(m_pSignalDecoder-&gt;isOutputTriggerActive(OVP_GD_Algorithm_SignalStreamDecoder_OutputTriggerId_ReceivedHeader))</div>
<div class="line">                {</div>
</div><!-- fragment --></p>
<p>In case a header was received, we simply request the initialization of the signal processing algorithm by activating its initialize trigger. When its process method is called next, this trigger activation status evaluates to true, causing the algorithm to initialize its output matrix. <div class="fragment"><div class="line">                        m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a02c9114b1cbeaf0ec9904f27d63035ca" title="Calls the processing method of the algorithm.">process</a>(OVP_Algorithm_SignalProcessingAlgorithm_InputTriggerId_Initialize);</div>
</div><!-- fragment --></p>
<p>At this point, the header part of the output stream can be encoded. <div class="fragment"><div class="line">                        m_pSignalEncoder-&gt;process(OVP_GD_Algorithm_SignalStreamEncoder_InputTriggerId_EncodeHeader);</div>
</div><!-- fragment --></p>
<p>Lastly, the output chunk can be marked as ready to be sent. This will let the kernel send it to the boxes that are connected to this output. One thing that we did not notice is that each stream buffer corresponds to a given time period. This time period is retrieved thanks to the getInputChunkStartTime and getInputChunkEndTime functions of the dynamic context. Similarly, when marking an output chunk as ready to send, the box must specify the time period that this chunk corresponds to. <div class="fragment"><div class="line"></div>
<div class="line">                        l_rDynamicBoxContext.markOutputAsReadyToSend(0, l_rDynamicBoxContext.getInputChunkStartTime(0, i), l_rDynamicBoxContext.getInputChunkEndTime(0, i));</div>
<div class="line">                }</div>
</div><!-- fragment --></p>
<p>In case a buffer is received, we can request the signal processing algorithm to process it. This is where the first sample of each channel is reset to 0, while any other sample is left untouched. <div class="fragment"><div class="line">                <span class="keywordflow">if</span>(m_pSignalDecoder-&gt;isOutputTriggerActive(OVP_GD_Algorithm_SignalStreamDecoder_OutputTriggerId_ReceivedBuffer))</div>
<div class="line">                {</div>
<div class="line">                        m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a02c9114b1cbeaf0ec9904f27d63035ca" title="Calls the processing method of the algorithm.">process</a>(OVP_Algorithm_SignalProcessingAlgorithm_InputTriggerId_Process);</div>
</div><!-- fragment --></p>
<p>Depending on the outcome of the actual processing, we may be ready to request a buffer encoding. The processing status is checked using the "process done" output trigger : when set to true, a buffer was successfully processed. <div class="fragment"><div class="line"></div>
<div class="line">                        <span class="keywordflow">if</span>(m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#aa86df50552efb84ea08b442f0185e8b6" title="Tests whether an output trigger is activated or not.">isOutputTriggerActive</a>(OVP_Algorithm_SignalProcessingAlgorithm_OutputTriggerId_ProcessDone))</div>
<div class="line">                        {</div>
</div><!-- fragment --></p>
<p>It is now time to encode the processed matrix. <div class="fragment"><div class="line">                                m_pSignalEncoder-&gt;process(OVP_GD_Algorithm_SignalStreamEncoder_InputTriggerId_EncodeBuffer);</div>
</div><!-- fragment --></p>
<p>As was done for the header chunk, this new output chunk is flagged as ready to send with the corresponding time period. <div class="fragment"><div class="line"></div>
<div class="line">                                l_rDynamicBoxContext.markOutputAsReadyToSend(0, l_rDynamicBoxContext.getInputChunkStartTime(0, i), l_rDynamicBoxContext.getInputChunkEndTime(0, i));</div>
<div class="line">                        }</div>
<div class="line">                }</div>
</div><!-- fragment --></p>
<p>Lastly, in case the decoder decoded an end node, we do not have to process anything. This just means that the input stream is closed and that no more buffers will be received from it. A new header would have to be sent first for new buffers to be received again.</p>
<p>Here, we just have to notify the following boxes that an end node was decoded. This is done by encoding and sending such a node. <div class="fragment"><div class="line">                <span class="keywordflow">if</span>(m_pSignalDecoder-&gt;isOutputTriggerActive(OVP_GD_Algorithm_SignalStreamDecoder_OutputTriggerId_ReceivedEnd))</div>
<div class="line">                {</div>
<div class="line">                        m_pSignalEncoder-&gt;process(OVP_GD_Algorithm_SignalStreamEncoder_InputTriggerId_EncodeEnd);</div>
</div><!-- fragment --></p>
<p>As for header and buffer chunks, we mark this new output chunk as ready to send with the corresponding time period. <div class="fragment"><div class="line"></div>
<div class="line">                        l_rDynamicBoxContext.markOutputAsReadyToSend(0, l_rDynamicBoxContext.getInputChunkStartTime(0, i), l_rDynamicBoxContext.getInputChunkEndTime(0, i));</div>
<div class="line">                }</div>
</div><!-- fragment --></p>
<p>Finally, since the input chunk was processed, we can notify the kernel that it can now be released. The chunk object won't be effectively released until the process function returns. This call can rather be seen as 'flagging' the chunk for deletion. <div class="fragment"><div class="line"></div>
<div class="line">                l_rDynamicBoxContext.markInputAsDeprecated(0, i);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="Doc_Tutorial_Developer_SignalProcessing_Conclusion"></a>
Conclusion</h1>
<p>Now that both plugins are created, we have to register them to the kernel at plugin loading time. For this reason, in <code>ovp_main.cpp</code> we use the <code>OVP_Declare_New</code> macro as follows : </p>
<div class="fragment"><div class="line">OVP_Declare_New(OpenViBEPlugins::Samples::CAlgorithmSignalProcessingAlgorithmDesc);</div>
<div class="line">OVP_Declare_New(OpenViBEPlugins::Samples::CBoxAlgorithmSignalProcessingBoxAlgorithmDesc);</div>
</div><!-- fragment --> </div></div><!-- contents -->
	</div>
	<div class='clear-both'></div>
	<div id="footer">
		<center>
		<table width=95%>
			<tr>
				<td style="text-align:left;"><a href="#page-top">Back to top</a></td>
				<td style="text-align:right;">Generated on Fri Sep 26 2014 00:47:34 for Documentation by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.1.2</td>
			</tr>
		</table>
		</center>
	</div>
</div>
</body>
</html>
