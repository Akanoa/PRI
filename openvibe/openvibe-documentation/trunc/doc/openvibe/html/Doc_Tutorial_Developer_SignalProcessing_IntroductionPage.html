<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>OpenViBE documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<!-- <link href="tabs.css" rel="stylesheet" type="text/css"> -->
</head>
<body>
<div id="main">
	<div id="title">
		<center>
		<a name="page-top"></a>
		<table width=95%>
			<tr>
				<td><a href="http://openvibe.inria.fr" class="leaving-link" onclick="window.open(this.href,'openvibe-software'); return false;"><img src="logo.png" /></a></td>
				<td width=100%>OpenViBE Documentation</td>
			</tr>
		</table>
		</center>
	</div>
	<div id="menu">
		<div id="menu-content">
			<ul>
				<li><a href="index.html">OpenViBE Documentation</a></li>
			</ul>
			<div class="menu-title">Doxygen</div>
			<ul>
				<!-- <li><a href="pages.html">Related</a></li> -->
				<li><a href="modules.html">Modules</a></li>
				<li><a href="namespaces.html">Namespaces</a></li>
				<li><a href="annotated.html">Class List</a>
				<li><a href="classes.html">Class Index</a>
				<li><a href="hierarchy.html">Class Hierarchy</a>
				<!-- <li><a href="files.html">Files (buggy)</a></li> -->
			</ul>
			<div class="menu-title">Quick Access</div>
			<ul>
				<li><a href="http://openvibe.inria.fr/start" class="leaving-link">Video Tutorials</a></li>
				<li><a href="http://openvibe.inria.fr/faq">FAQ</a></li>
				<li><a href="http://openvibe.inria.fr/license">Licence</a></li>
				<li><a href="http://openvibe.inria.fr/build-instructions/">Build Instructions</a></li>
				<li><a href="http://openvibe.inria.fr/documentation-index/#User+Documentation">User Doc</a></li>
				<li><a href="http://openvibe.inria.fr/documentation-index/#Developer+Documentation">Developer Doc</a></li>
				<li><a href="Doc_BoxAlgorithms.html">Exisiting Boxes</a></li>
			</ul>
			<div class="menu-title">Contact</div>
			<ul>
				<li><a href="http://openvibe.inria.fr" class="leaving-link" onclick="window.open(this.href,'openvibe-software'); return false;">Software Home</a></li>
				<li><a href="http://openvibe.inria.fr/forum" class="leaving-link" onclick="window.open(this.href,'openvibe-forum'); return false;">Forum</a></li>
				<li><a href="https://gforge.inria.fr/projects/openvibe" class="leaving-link" onclick="window.open(this.href,'openvibe-forge'); return false;">INRIA gForge</a></li>
				<li><a href="https://gforge.inria.fr/mail/?group_id=276" class="leaving-link" onclick="window.open(this.href,'openvibe-forge'); return false;">Mailing Lists</a></li>
				<li><a href="http://openvibe.inria.fr/tracker" class="leaving-link" onclick="window.open(this.href,'openvibe-tracker'); return false;">Bug Tracker</a></li>
				<li><a href="http://www.irisa.fr/bunraku/OpenViBE/wiki/index.php?title=Main_Page" class="leaving-link" onclick="window.open(this.href,'openvibe-wiki'); return false;">Research Project</a></li>
				<li><b>IRC</b> : <span style="font-size: x-small; font-style: italic;">#openvibe</span> on <span style="font-size: x-small; font-style: italic;">irc.freenode.net</span></li>
				<li><b>Project Leader</b> : Anatole L&eacute;cuyer, Inria <span style="font-size: x-small; font-style: italic;">(anatole dot lecuyer at inria dot fr)</span></li>
				<li><b>Lead Software Engineer</b> : Laurent Bonnet, Inria <span style="font-size: x-small; font-style: italic;">(laurent dot bonnet at inria dot fr)</span></li>
			</ul>
			<div class="menu-title">Share this</div>
			<ul><li><span style="font-size: x-small; font-style: italic;">This documentation is licenced under <b>CC-BY-SA</b></span></li></ul>
			<td><a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode" class="leaving-link" onclick="window.open(this.href,'cc-by-sa'); return false;"><img src="cc-by-sa.png" /></a></td>
			<br>
			<div class="menu-title">Search</div>
			<form action="search.php" method="get" id="search">
				<fieldset>
					<input class="search" type="text" name="q" value="Quick Search..." onfocus="this.value='';" />
				</fieldset>
			</form>
		</div>
	</div>
	<div class="content-container">
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="Doc_DeveloperDocumentation.html">Developer Documentation</a></li><li class="navelem"><a class="el" href="Doc_DeveloperTutorials.html">Developer tutorials</a></li><li class="navelem"><a class="el" href="Doc_DeveloperDocumentation_Plugin.html">Developing a Plugin</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> algorithms and boxes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="important"> This documentation page is deprecated since <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> 0.12.0 (oct 2011), and won't be maintained.  The new page can be found  <a href="http://openvibe.inria.fr/introduction-algo-boxes/"> here </a> .</div><ul>
<li><b>NB:</b> Document based on <b> <a class="el" href="namespaceOpenViBE.html" title="Main OpenViBE namespace.">OpenViBE</a> 0.8.0 </b> (30-sep-2010).</li>
</ul>
<h1><a class="anchor" id="Doc_Tutorial_Developer_SignalProcessing_ExtendingOpenViBE"></a>
Extending OpenViBE</h1>
<p>There are two ways Â§OpenViBEÂ§ can be extended. One is to write new algorithms, that are only used by programmers in order to perform a specific operation. The second is to create new boxes (also named Box Algorithms) that can be used by authors in scenarios.</p>
<p>Depending on the task at hand, one might have to implement new algorithms and/or boxes. While it is possible to write a box which doesn't make use of any algorithm (in the sense of Â§OpenViBEÂ§, meaning all signal processing code is written directly in the box), it is usually desirable to encapsulate signal processing operations in algorithms. The gain is not necessarily obvious at first, but it becomes evident in the long term, allowing box developers to reuse existing algorithms and build new boxes faster. In any case, it's up to the programmer to determine what operations are generic enough to justify their encapsulation in an algorithm.</p>
<p>This tutorial demonstrates how to add a new signal processing algorithm to Â§OpenViBEÂ§, and how to create a new box which makes use of it. It comprises the following three sections :</p>
<ul>
<li><a class="el" href="Doc_Tutorial_Developer_SignalProcessing_IntroductionPage.html#Doc_Tutorial_Developer_SignalProcessing_Introduction">Introduction</a></li>
<li><a class="el" href="Doc_Tutorial_Developer_SignalProcessing_Algorithm.html">Implementing a signal processing algorithm</a></li>
<li><a class="el" href="Doc_Tutorial_Developer_SignalProcessing_Box.html">Implementing a Box</a></li>
</ul>
<p>After reading this tutorial, you should be able to start building your own plugins. If you have any trouble when developing with openvibe, feel free to contact experienced developers on the Forum, mailing list, or IRC channel.</p>
<h1><a class="anchor" id="Doc_Tutorial_Developer_SignalProcessing_Introduction"></a>
Introduction</h1>
<h2><a class="anchor" id="Doc_Tutorial_Developer_SignalProcessing_AlgoInternals"></a>
Algorithm internals</h2>
<p>The algorithm is a very generic, low level component which can easily communicate with other algorithms. An algorithm can be called by other algorithms or by a Box, the high level component encapsulating a whole process.</p>
<p>An Algorithm implementation is divided in 2 parts :</p>
<ul>
<li>The <b>Algorithm</b> implementing <a class="el" href="classOpenViBE_1_1Plugins_1_1IAlgorithm.html" title="Abstract algorithm, base element of §OpenViBE§ processing objectsThis class should be derived by any pl...">OpenViBE::Plugins::IAlgorithm</a>, that do the task on the data structures</li>
<li>The <b>Algorithm</b> <b>Descriptor</b> implementing <a class="el" href="classOpenViBE_1_1Plugins_1_1IAlgorithmDesc.html" title="Algorithm plugin descriptorThis class should be derived by any plugin developper in order to describe...">OpenViBE::Plugins::IAlgorithmDesc</a>, that gives the kernel an abstract view of the algorithm and an easy way to create a new instance of the algorithm.</li>
</ul>
<p>An algorithm processes one or more input and returns one or more outputs. In the implemented algorithm object, each input and output has a corresponding data structure. For the programmer to easily manage these structures, we provide the template handler <a class="el" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html" title="Helper class in order to manipulate IParameter and IParameter values natively.">OpenViBE::Kernel::TParameterHandler</a>. Therefore the algorithm has one TParameterHandler per input or output parameter. The type of parameter you can specify are described in the <a class="el" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html" title="Helper class in order to manipulate IParameter and IParameter values natively.">OpenViBE::Kernel::TParameterHandler</a> documentation (boolean, int64, StimulationSet, etc.). For example the following handler will manage an input Matrix: </p>
<div class="fragment"><div class="line"><a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::IMatrix* &gt;</a> ip_pMatrix;</div>
</div><!-- fragment --><p> This input matrix handler has to be initialized to be connected to the concrete <a class="el" href="classOpenViBE_1_1Kernel_1_1IParameter.html" title="Generic parameter handler for configurable objects.">OpenViBE::Kernel::IParameter</a>. </p>
<div class="fragment"><div class="line">ip_pMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a7511aca374e126f43beb7879d57699c7" title="Connects this parameter handler to a concrete IParameter pointer.">initialize</a>(inputParameterMatrixPointer);</div>
</div><!-- fragment --><p>The algorithm communicate with its surroundings using input and output <b>triggers</b> (that mean for example "Do the process", or "Process successful"). The kernel (<a class="el" href="classOpenViBE_1_1Kernel_1_1IAlgorithmContext.html" title="Exectution context for algorithm objects.">OpenViBE::Kernel::IAlgorithmContext</a>) provides 2 functions related to triggers, to be used on an algorithm object:</p>
<ul>
<li><code> activateOutputTrigger(OpenViBE::CIdentifier&amp; rOutputTriggerIdentifier, OpenViBE::boolean bTriggerState) </code> sets the state of an output trigger of the algorithm.</li>
<li><code> isInputTriggerActive(OpenViBE::CIdentifier&amp; rInputTriggerIdentifier) </code> checks the current state of an input trigger.</li>
</ul>
<p>The figure below illustrates the algorithm concept with a processing unit that use an input matrix to output a second matrix. The algorithm is controlled by 2 input triggers that ask the algorithm to initialize or start some process. When the process is done, the algorithm rises a dedicated trigger. </p>
<div class="image">
<img src="algo-diagram.png" alt="algo-diagram.png"/>
<div class="caption">
An algorithm, its input, output and triggers</div></div>
 <h2><a class="anchor" id="Doc_Tutorial_Developer_SignalProcessing_BoxInternals"></a>
Box internals</h2>
<p>A box is an abstract view of a single processing chain, that may include several algorithms linked to perform a precise task. The Box manages all the data structures The box has its own inputs and outputs, all receiving or sending encoded data in <a class="el" href="namespaceEBML.html" title="Namespace for the EBML lib.">EBML</a> structures. These data are divided in blocks called "chunks". Chunk management is done through the box's dynamic context <a class="el" href="classOpenViBE_1_1Kernel_1_1IBoxIO.html" title="Main §OpenViBE§ box interface to communicate with the kernelThis context allows the object which uses i...">OpenViBE::Kernel::IBoxIO</a>. Once a chunk is received, the box can put it on the input(s) of the algorithm(s). Most of the time the first algorithm used will be a <a class="el" href="namespaceEBML.html" title="Namespace for the EBML lib.">EBML</a> decoder, that extracts the data from the chunk. The last algorithm in the chain (most of the time an <a class="el" href="namespaceEBML.html" title="Namespace for the EBML lib.">EBML</a> encoder) rises its output trigger signaling the end of process, meaning that the output chunk has been produced. The box can then mark the output chunk as ready to be sent !</p>
<p>The box declares each algorithm used along with its inputs and outputs. The Algorithm itself is represented by an <a class="el" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html" title="Application interface to an algorithm plugin.">OpenViBE::Kernel::IAlgorithmProxy</a> object. The inputs and outputs are again contained in <a class="el" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html" title="Helper class in order to manipulate IParameter and IParameter values natively.">OpenViBE::Kernel::TParameterHandler</a> handlers. Here is an example of such declarations in the box definition : </p>
<div class="fragment"><div class="line"><a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html" title="Application interface to an algorithm plugin.">OpenViBE::Kernel::IAlgorithmProxy</a>* m_pSignalProcessingAlgorithm;</div>
<div class="line"><a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::IMatrix* &gt;</a> ip_pSignalProcessingAlgorithmMatrix;</div>
<div class="line"><a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html">OpenViBE::Kernel::TParameterHandler &lt; OpenViBE::IMatrix* &gt;</a> op_pSignalProcessingAlgorithmMatrix;</div>
</div><!-- fragment --><p>The IAlgorithmProxy class is a user interface to an IAlgorithm instanciated object. Its purpose is to automatically handle input / output trigger activation and to help in calling processing methods. During the initialization phase, the box asks the <a class="el" href="classOpenViBE_1_1Kernel_1_1IAlgorithmManager.html" title="Manager for all kind of plugin algorithms.">OpenViBE::Kernel::IAlgorithmManager</a> instance of the kernel to create an instance of the Algorithm. It also initializes the inputs and outputs handlers, giving them the actual parameters of the created algorithm. The code below illustrates this process with the same algorithm as above. </p>
<div class="fragment"><div class="line">CIdentifier l_idAlgorithmIdentifier = this-&gt;getAlgorithmManager().createAlgorithm(OVP_ClassId_Algorithm_SignalProcessingAlgorithm);</div>
<div class="line">m_pSignalProcessingAlgorithm=&amp;this-&gt;getAlgorithmManager().getAlgorithm(l_idAlgorithmIdentifier);</div>
<div class="line">m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#ad58fbcdf752604b2392266a0c77f93cd" title="Initializes the algorithm.">initialize</a>();</div>
<div class="line"></div>
<div class="line">ip_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a7511aca374e126f43beb7879d57699c7" title="Connects this parameter handler to a concrete IParameter pointer.">initialize</a>(</div>
<div class="line">         m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a01ed90db74b699befce9cad8704e2ffd" title="Gets the parameter details of a specific input parameter.">getInputParameter</a>(OVP_Algorithm_SignalProcessingAlgorithm_InputParameterId_Matrix));</div>
<div class="line">op_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a7511aca374e126f43beb7879d57699c7" title="Connects this parameter handler to a concrete IParameter pointer.">initialize</a>(</div>
<div class="line">         m_pSignalProcessingAlgorithm-&gt;<a class="code" href="classOpenViBE_1_1Kernel_1_1IAlgorithmProxy.html#a68d15f4727a654c413b013f092247000" title="Gets the parameter details of a specific output parameter.">getOutputParameter</a>(OVP_Algorithm_SignalProcessingAlgorithm_OutputParameterId_Matrix));</div>
</div><!-- fragment --><p>Finally, the algorithms inputs and outputs are linked together with the <code>setReferenceTarget</code> function of the TParameterHandler handler. In the example below, the input <code>ip_pSignalProcessingAlgorithmMatrix</code> of the signal processing algorithm will be connected to the output <code>op_pDecodedMatrix</code> coming from a stream decoder algorithm. </p>
<div class="fragment"><div class="line">ip_pSignalProcessingAlgorithmMatrix.<a class="code" href="classOpenViBE_1_1Kernel_1_1TParameterHandler.html#a07b427c2abdd0c5e20924ede4d613f57" title="Sets a new reference target.">setReferenceTarget</a>(op_pDecodedMatrix);</div>
</div><!-- fragment --><p> Note that it is the input that set its output reference target, and not the opposite. The reason is simple : an output can be sent to several inputs, but an input can have only one source output.</p>
<h2><a class="anchor" id="Doc_Tutorial_Developer_SignalProcessing_Design"></a>
Designing the tutorial plugin</h2>
<p>In this tutorial, we will build a Box with one Signal input and one Signal output. The box will simply modify the incoming signal chunks by setting to 0 the first sample of every channel.</p>
<p>The data streams between boxes are all encapsulated in <a class="el" href="namespaceEBML.html" title="Namespace for the EBML lib.">EBML</a> structures. The first Algorithm decode these <a class="el" href="namespaceEBML.html" title="Namespace for the EBML lib.">EBML</a> memory buffers coming on the Signal input. These chuncks are transformed into a convenient data container called streamed matrix, much easier to manipulate than <a class="el" href="namespaceEBML.html" title="Namespace for the EBML lib.">EBML</a> stream. The Signal Decoder also outputs the sampling frequency of the incoming signal.</p>
<p>The second algorithm is the signal processing algorithm we will implement in this tutorial. It modify an input streamed matrix containing some samples, and output the result.</p>
<p>The last algorithm is a Signal Encoder, that constructs new <a class="el" href="namespaceEBML.html" title="Namespace for the EBML lib.">EBML</a> chunks using a sampling frequency value and a streamed matrix containing the signal samples.</p>
<p>This tutorial will show you how to :</p>
<ul>
<li>Implement from scratch the signal processing algorithm</li>
<li>Implement a box that will use the new algorithm, along with the given signal decoder and encoder.</li>
<li>Connect within the box the 3 algorithms</li>
</ul>
<p>The figure below illustrates the design we will achieve, with the corresponding kernel calls used in the implementation. All variable prefixed with <code>ip_</code> refer to inputs, <code>op_</code> refer to outputs. If you are lost during the tutorial, you can go back to this figure. </p>
<div class="image">
<img src="box-diagram.png" alt="box-diagram.png"/>
<div class="caption">
Design of the new plugin</div></div>
<p> Now please go on to the next step : <a class="el" href="Doc_Tutorial_Developer_SignalProcessing_Algorithm.html">Implementing a signal processing algorithm</a> </p>
</div></div><!-- contents -->
	</div>
	<div class='clear-both'></div>
	<div id="footer">
		<center>
		<table width=95%>
			<tr>
				<td style="text-align:left;"><a href="#page-top">Back to top</a></td>
				<td style="text-align:right;">Generated on Fri Sep 26 2014 00:47:34 for Documentation by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.8.1.2</td>
			</tr>
		</table>
		</center>
	</div>
</div>
</body>
</html>
